using System.Net.Http.Json;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Janet.DubCore.Models;

namespace Janet.DubCore.Services;

/// <summary>
/// A service to determine user intent and extract entities from a query using the Ollama API.
/// </summary>
public class IntentService
{
    // Constants for magic strings to avoid typos and centralize values.
    private const string ErrorIntent = "error";
    private const string MessageKey = "message";
    private const string DetailsKey = "details";
    private const string StatusCodeKey = "status_code";
    
    // Using IHttpClientFactory-managed HttpClient is the modern best practice.
    private readonly HttpClient _httpClient;
    private readonly ILoggingService _loggingService;
    private readonly string _modelName;
    private readonly string _ollamaApiUrl;

    public IntentService(HttpClient httpClient, IAppConfigService configService, ILoggingService loggingService)
    {
        _httpClient = httpClient;
        _loggingService = loggingService;

        _modelName = configService.Settings.Ollama.IntentModelName;
        // The base URL is now configured in Program.cs. We just need the relative path.
        _ollamaApiUrl = "/api/generate";

        _loggingService.LogInfo($"IntentService initialized for model [{_modelName}] targeting endpoint [{_httpClient.BaseAddress}{_ollamaApiUrl}]");
    }

    /// <summary>
    /// Sends a user query to the Ollama API to extract intent and entities as a JSON object.
    /// This method is designed to be resilient, handling various API and network failures gracefully.
    /// </summary>
    /// <param name="userQuery">The user's input query to analyze.</param>
    /// <param name="cancellationToken">A token to cancel the asynchronous operation.</param>
    /// <returns>
    /// An <see cref="OllamaIntent"/> object containing the extracted intent and entities,
    /// or a standardized error intent if the operation fails.
    /// </returns>
    public async Task<OllamaIntent> GetIntentAndEntitiesAsJsonAsync(string userQuery, CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(userQuery))
        {
            return CreateErrorResponse("Query cannot be empty.");
        }

        const string systemPrompt = @"You are an expert at extracting user intent and entities from a given query. 
Your response MUST be a single, well-formed JSON object and nothing else.
The JSON object should have two top-level properties:
1. 'intent': A string representing the user's primary goal (e.g., 'set_timer', 'find_weather'). Use snake_case for the intent name.
2. 'entities': An object containing key-value pairs of extracted information (e.g., {'location': 'Paris', 'date': 'tomorrow'}).
Do not add any explanations, comments, or markdown formatting around the JSON.";

        var requestPayload = new OllamaRequest
        {
            Model = _modelName,
            System = systemPrompt,
            Prompt = $"User Query: \"{userQuery}\"",
            Format = "json",
            Stream = false
        };

        try
        {
            // PostAsJsonAsync handles serialization for us.
            HttpResponseMessage response = await _httpClient.PostAsJsonAsync(_ollamaApiUrl, requestPayload, cancellationToken);

            // Throws an HttpRequestException if the response status code is not a success code.
            // This simplifies the control flow by catching non-success codes in the HttpRequestException block.
            response.EnsureSuccessStatusCode();

            var ollamaResponse = await response.Content.ReadFromJsonAsync<OllamaResponse>(cancellationToken: cancellationToken);

            if (string.IsNullOrWhiteSpace(ollamaResponse?.Response))
            {
                _loggingService.LogWarning("Ollama response content is null or empty.");
                return CreateErrorResponse("Model response is null or empty.");
            }

            // The 'Response' property contains the JSON string generated by the model.
            var intent = JsonSerializer.Deserialize<OllamaIntent>(ollamaResponse.Response);

            return intent ?? CreateErrorResponse("Failed to parse intent from model response.");
        }
        catch (HttpRequestException e)
        {
            _loggingService.LogError($"Ollama API call failed: {e.Message}", e);
            return CreateHttpErrorResponse(e);
        }
        catch (JsonException e)
        {
            _loggingService.LogError($"Failed to deserialize Ollama response: {e.Message}", e);
            return CreateErrorResponse("Failed to parse JSON response from the service.", e.Message);
        }
        catch (TaskCanceledException)
        {
            _loggingService.LogWarning("Ollama API request was canceled.");
            return CreateErrorResponse("The request was canceled.");
        }
        catch (Exception e)
        {
            _loggingService.LogError($"An unexpected error occurred in IntentService: {e.Message}", e);
            return CreateErrorResponse("An unexpected error occurred.", e.Message);
        }
    }

    // Helper method to create a standardized error response.
    private static OllamaIntent CreateErrorResponse(string message, string? details = null)
    {
        var intent = new OllamaIntent { intent = ErrorIntent };
        intent.entities[MessageKey] = message;
        if (details is not null)
        {
            intent.entities[DetailsKey] = details;
        }
        return intent;
    }

    // Helper method to create a standardized HTTP error response.
    private static OllamaIntent CreateHttpErrorResponse(HttpRequestException e)
    {
        var intent = new OllamaIntent { intent = ErrorIntent };
        intent.entities[MessageKey] = "Could not connect to the Ollama service. Please ensure it is running.";
        intent.entities[DetailsKey] = e.Message;
        if (e.StatusCode is not null)
        {
            intent.entities[StatusCodeKey] = ((int)e.StatusCode).ToString();
        }
        return intent;
    }
}